package main

import (
	"crypto/rand"
	"encoding/base32"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"sort"
	"strconv"
	"strings"

	cf "github.com/thepcn3rd/goAdvsCommonFunctions"
)

/**
References:

https://github.com/boombuler/barcode/
https://github.com/pquerna/otp/

**/

type TOTPOptionsStruct struct {
	AppName             string
	AccountName         string
	HashValidTime       int    // 30 seconds is the default
	Algorithm           string // Set to be SHA1
	GeneratedSecretSize int    // 10 bytes is the default or 20
	GeneratedSecret     []byte
	B32Secret           string // Generated by B32 of the Generated Secret
	QRCodeURL           url.URL
}

type Configuration struct {
	AppName           string `json:"appName"`
	AccountName       string `json:"accountName"`
	WebServerPort     int    `json:"webServerPort"`
	UseCyberChefLocal bool   `json:"useCyberChefLocal"`
}

func EncodeQuery(v url.Values) string {
	if v == nil {
		return ""
	}
	var buf strings.Builder
	keys := make([]string, 0, len(v))
	for k := range v {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		vs := v[k]
		keyEscaped := url.PathEscape(k) // changed from url.QueryEscape
		for _, v := range vs {
			if buf.Len() > 0 {
				buf.WriteByte('&')
			}
			buf.WriteString(keyEscaped)
			buf.WriteByte('=')
			buf.WriteString(url.PathEscape(v)) // changed from url.QueryEscape
		}
	}
	return buf.String()
}

func GenerateKey(t TOTPOptionsStruct) TOTPOptionsStruct {
	t.HashValidTime = 30
	t.Algorithm = "SHA1"
	t.GeneratedSecretSize = 20
	t.GeneratedSecret = make([]byte, t.GeneratedSecretSize)
	_, err := io.ReadFull(rand.Reader, t.GeneratedSecret)
	cf.CheckError("Unable to generate a random secret", err, true)

	b32NoPadding := base32.StdEncoding.WithPadding(base32.NoPadding)
	t.B32Secret = b32NoPadding.EncodeToString(t.GeneratedSecret)

	// Generate URL to build the QR Code
	t.QRCodeURL.Scheme = "otpauth"
	t.QRCodeURL.Host = "totp"
	t.QRCodeURL.Path = "/" + t.AppName + ":" + t.AccountName

	//Build URL Path Values
	v := url.Values{}
	v.Set("secret", t.B32Secret)
	v.Set("issuer", t.AppName)
	v.Set("period", strconv.Itoa(t.HashValidTime))
	v.Set("algorithm", t.Algorithm)
	v.Set("digits", "6")
	t.QRCodeURL.RawQuery = EncodeQuery(v)

	return t
}

func loadConfig(cPtr string) Configuration {

	var c Configuration
	fmt.Println("Loading the following config file: " + cPtr + "\n")
	// go logToSyslog(fmt.Sprintf("Loading the following config file: %s\n", *ConfigPtr))
	configFile, err := os.Open(cPtr)
	cf.CheckError("Unable to open the configuration file", err, true)
	defer configFile.Close()
	decoder := json.NewDecoder(configFile)
	// var config Configuration
	if err := decoder.Decode(&c); err != nil {
		cf.CheckError("Unable to decode the configuration file", err, true)
	}

	return c
}

func main() {
	var config Configuration
	var totpOptions TOTPOptionsStruct

	ConfigPtr := flag.String("config", "config.json", "Configuration file to load for the proxy")
	flag.Parse()

	config = loadConfig(*ConfigPtr)

	totpOptions.AppName = config.AppName
	totpOptions.AccountName = config.AccountName

	totpOptions = GenerateKey(totpOptions)
	fmt.Printf("Generated Secret: %v\n", totpOptions.GeneratedSecret)
	fmt.Printf("B32 Secret Key: %s\n", totpOptions.B32Secret)
	fmt.Printf("QR Code URL: %s\n\n", &totpOptions.QRCodeURL)

	// Uses Cyber Chef to Generate the QR Code
	encodedQRCodeURL := base64.StdEncoding.EncodeToString([]byte((totpOptions.QRCodeURL).String()))
	encodedQRCodeURL = strings.ReplaceAll(encodedQRCodeURL, "=", "") // Remove the = or when it is copied into the browser the URL does not work...
	var onlineURL string
	if config.UseCyberChefLocal {
		onlineURL = "http://127.0.0.1:" + strconv.Itoa(config.WebServerPort) + "/index.html"
	} else {
		onlineURL = "https://gchq.github.io/CyberChef/"
	}
	onlineURL = onlineURL + "#recipe=Generate_QR_Code('PNG',10,10,'Medium')&input=" + encodedQRCodeURL
	fmt.Printf("Copy this URL into your Browser to Generate the QR Code: %s\n\n", onlineURL)

	if config.UseCyberChefLocal {
		// Generate a static webserver with CyberChef
		cf.CreateDirectory("/static")
		http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
			http.FileServer(http.Dir("./static")).ServeHTTP(w, r)
		})
		listeningPort := ":" + strconv.Itoa(config.WebServerPort)
		go http.ListenAndServe(listeningPort, nil) // Background the webserver
	}

	cf.PressEnterKeytoContinue()

}
